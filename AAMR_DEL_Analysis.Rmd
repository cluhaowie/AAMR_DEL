---
title: "AAMR_DEL_Analysis"
author: "Du, Haowei"
date: "2024-11-10"
output: html_document
---
# Step0
```{r}
# Load necessary libraries
library(dplyr)
library(regioneR)
library(ggplot2)
library(forcats)
library(stringr)
library(igraph)
# Get repeatmask annoation from ucsc
chr <- paste0("chr",c(1))
UCSC <- DBI::dbConnect(MySQL(),user='genome',dbname='hg38',host='genome-mysql.cse.ucsc.edu')
rmsk_UCSC <- dbGetQuery(UCSC,paste0("SELECT * FROM rmsk WHERE `genoName` IN ('",paste0(chr,collapse = "','"),"') "))

rmsk.gr <- rmsk%>%
  regioneR::toGRanges()
strand(rmsk.gr) <- rmsk$strand
```

# Identify unique alleles
```{r}
# select_del:
# This is a table created by filtering and processing structural variant (SV) data 
# aggregated from the 100-genome dataset, generated by the DRAGEN pipeline. 
# The dataset includes variants with specific length constraints (342â€“5000 bp or >7000 bp)
# and incorporates key information such as chromosome, position, and a unique key
# for overlap analysis and annotation.

gr1 <- select_del%>%
  dplyr::select(CHROM,POS,END,ID,key)%>%
  regioneR::toGRanges()
# Filter deletions based on size and create a unique key
select_del <- dragen_del %>%
  filter(between(SVLEN, 342, 5000) | SVLEN > 7000) %>%
  mutate(key = paste0(CHROM, "_", POS))

# Apply similar filtering to a second dataset
select_del <- dragen_delhold_100 %>%
  filter(between(SVLEN, 342, 5000) | SVLEN > 7000) %>%
  mutate(key = paste0(ID, "_", CHROM, "_", POS))

# Convert start and end positions to GRanges for overlap analysis
select_del.start <- select_del %>%
  dplyr::select(CHROM, POS, POS) %>%
  regioneR::toGRanges()

select_del.end <- select_del %>%
  dplyr::select(CHROM, END, END) %>%
  regioneR::toGRanges()

# Annotate overlaps with repeat masker data
ov <- findOverlaps(select_del.start, rmsk.gr)
select_del$start_element <- "NA"
select_del$start_element_Family <- "NA"
select_del[queryHits(ov), ]$start_element <- rmsk[subjectHits(ov), ]$repName
select_del[queryHits(ov), ]$start_element_Family <- rmsk[subjectHits(ov), ]$repFamily

ov <- findOverlaps(select_del.end, rmsk.gr)
select_del$end_element <- "NA"
select_del$end_element_Family <- "NA"
select_del[queryHits(ov), ]$end_element <- rmsk[subjectHits(ov), ]$repName
select_del[queryHits(ov), ]$end_element_Family <- rmsk[subjectHits(ov), ]$repFamily

# Summarize mechanisms based on repeat families
mechanism_sum <- select_del %>%
  mutate(mechanism = paste0(start_element, "-", end_element)) %>%
  mutate(mechanism_fam = paste0(start_element_Family, "-", end_element_Family)) %>%
  group_by(mechanism_fam) %>%
  summarise(count = n())

# Analyze Alu-Alu mediated recombination (AAMR)
AAMR_perg_df <- select_del %>%
  mutate(mechanism_fam = paste0(start_element_Family, "-", end_element_Family)) %>%
  filter(mechanism_fam == "Alu-Alu") %>%
  mutate(
    start_element = stringr::str_extract(start_element, "^.{4}"),
    end_element = stringr::str_extract(end_element, "^.{4}")
  ) %>%
  filter(!is.na(start_element), !is.na(end_element)) %>%
  mutate(mechnism = paste0(start_element, "-", end_element)) %>%
  mutate(
    mechnism = case_when(
      mechnism %like% "FLAM" ~ "Alu_FLAM",
      mechnism %like% "FRAM" ~ "Alu_FRAM",
      mechnism == "AluY-AluS" ~ "AluS-AluY",
      mechnism == "AluJ-AluS" ~ "AluS-AluJ",
      mechnism == "AluJ-AluY" ~ "AluY-AluJ",
      .default = mechnism
    )
  )
# Aggregate data for plotting
AAMR_perg <- AAMR_perg_df %>%
  group_by(mechnism, ID) %>%
  summarise(count = n())

# Calculate statistics and create a bar plot
F2_100genome <- AAMR_perg %>%
  group_by(ID) %>%
  mutate(total = sum(count)) %>%
  mutate(ratio = count / total) %>%
  group_by(mechnism) %>%
  summarise(
    mean_ratio = round(mean(ratio), 2),
    sd_ratio = sd(ratio)
  ) %>%
  mutate(
    se = sd_ratio / sqrt(100),
    lower_ci = mean_ratio - qt(0.975, df = 100 - 1) * se,
    upper_ci = mean_ratio + qt(0.975, df = 100 - 1) * se
  ) %>%
  ggplot(aes(x = forcats::fct_rev(forcats::fct_reorder(mechnism, mean_ratio)), y = mean_ratio)) +
  geom_col() +
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci, width = .5)) +
  geom_text(aes(label = mean_ratio), vjust = -0.5) +
  ylim(0, 1) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1), axis.title.x = element_blank())


```

# Annotate the validated AAMR-DEL with gnomad alleles
```{r}
AAMRs_Tables <- openxlsx::read.xlsx("Table S5_v2.xlsx",startRow = 1)
AAMRs_Tables_filter <- AAMRs_Tables%>%mutate(
    chr = str_extract(`Deletion.size.(coordinates)`, "chr[0-9XY]+"), # Extract chromosome
  start = as.numeric(str_extract(`Deletion.size.(coordinates)`, "(?<=:)[0-9]+")), # Extract start
  end = as.numeric(str_extract(`Deletion.size.(coordinates)`, "(?<=-)[0-9]+")))%>%
  filter(Sanger.validating.AAMR.events=="Validated")%>%
  mutate(length=as.numeric(end)-as.numeric(start))

gr <- AAMRs_Tables_filter%>%
  select(chr,start,end,`AAMR#`)%>%regioneR::toGRanges()


gene_nLOF.df <- fread("gnomad_sv4.0_table.csv")%>%filter(SVTYPE%in%c("DEL"))
gene_nDUP.df <- fread("gnomad_sv4.0_table.csv")%>%filter(SVTYPE%in%c("DUP"))
gene_nLOF.gr <- gene_nLOF.df%>%select(CHROM,POS,END,ID)%>%regioneR::toGRanges()
gene_nDUP.gr <- gene_nDUP.df%>%select(CHROM,POS,END,ID)%>%regioneR::toGRanges()

calculate_reciprocal_overlap <- function(gr1, gr2, min_percentage = 80) {
  
  # Find overlaps
  overlaps <- findOverlaps(gr1, gr2)
  
  # Calculate intersected ranges for overlapping regions
  reciprocal_overlap <- pintersect(gr1[queryHits(overlaps)], gr2[subjectHits(overlaps)])
  overlap_lengths <- width(reciprocal_overlap)
  
  # Calculate reciprocal overlap percentages
  reciprocal_percentages <- data.frame(
    gr1_index = queryHits(overlaps),
    gr1_id = gr1$`AAMR#`[queryHits(overlaps)],
    gr2_index = subjectHits(overlaps),
    gr2_id = gsub("gnomAD-SV_v3_","",gr2$ID[subjectHits(overlaps)]),
    gr1_percentage = overlap_lengths / width(gr1[queryHits(overlaps)]) * 100,
    gr2_percentage = overlap_lengths / width(gr2[subjectHits(overlaps)]) * 100
  )
  
  # Filter for overlaps where both percentages meet the minimum threshold
  filtered_reciprocal <- reciprocal_percentages %>%
    filter(gr1_percentage >= min_percentage & gr2_percentage >= min_percentage)
  
  # Initialize output with NA values
  output <- rep(NA, length(gr1))
  
  # Process each unique `gr1` index to concatenate qualifying overlaps
  if (nrow(filtered_reciprocal) > 0) {
    result <- filtered_reciprocal %>%
      group_by(gr1_index) %>%
      summarise(
        overlap_info = paste0(
          gr2_id, "(", round(gr1_percentage, 1), "%-", round(gr2_percentage, 1), "%)", 
          collapse = "; "
        )
      )
    
    # Update output based on results
    output[result$gr1_index] <- result$overlap_info
  }
  
  # Convert to data frame for a consistent output
  output_df <- data.frame(gr1_id = seq_along(gr1), overlap_info = output)
  
  return(output_df)
}

output_df_del <- calculate_reciprocal_overlap(gr,gene_nLOF.gr)
output_df_dup <- calculate_reciprocal_overlap(gr,gene_nDUP.gr)
AAMRs_Tables_filter$gnmad_allele_del <- output_df_del$overlap_info
AAMRs_Tables_filter$gnmad_allele_dup <- output_df_dup$overlap_info

```



